(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{361:function(s,e,t){"use strict";t.r(e);var a=t(3),r=Object(a.a)({},(function(){var s=this,e=s.$createElement,t=s._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"abstract"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[s._v("#")]),s._v(" Abstract")]),s._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#abstract"}},[s._v("Abstract")])]),t("li",[t("a",{attrs:{href:"#redis-简述"}},[s._v("Redis 简述")])]),t("li",[t("a",{attrs:{href:"#redis-原理"}},[s._v("Redis 原理")])]),t("li",[t("a",{attrs:{href:"#数据淘汰策略"}},[s._v("数据淘汰策略")])]),t("li",[t("a",{attrs:{href:"#redis-生产适用场景"}},[s._v("Redis 生产适用场景")])]),t("li",[t("a",{attrs:{href:"#redis-优化"}},[s._v("Redis 优化")])]),t("li",[t("a",{attrs:{href:"#redis-分布式锁"}},[s._v("Redis 分布式锁")]),t("ul",[t("li",[t("a",{attrs:{href:"#分布式锁"}},[s._v("分布式锁")])])])]),t("li",[t("a",{attrs:{href:"#redis-分布式集群"}},[s._v("Redis 分布式集群")]),t("ul",[t("li",[t("a",{attrs:{href:"#redis-分布式锁"}},[s._v("Redis 分布式锁")])]),t("li",[t("a",{attrs:{href:"#redis-cluster-槽"}},[s._v("Redis Cluster 槽")])])])]),t("li",[t("a",{attrs:{href:"#redis-py"}},[s._v("redis-py")]),t("ul",[t("li",[t("a",{attrs:{href:"#strictredis"}},[s._v("StrictRedis()")])]),t("li",[t("a",{attrs:{href:"#append"}},[s._v("append()")])])])])])]),t("p"),s._v(" "),t("p",[s._v("Redis(Remote Dictionary Server) server 的启动：")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("redis-server.exe redis.windows.conf\n")])])]),t("p",[s._v("安装 redis-py:")]),s._v(" "),t("div",{staticClass:"language-sh extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[s._v("pip "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("install")]),s._v(" redis\n")])])]),t("p",[t("a",{attrs:{href:"https://redis-py.readthedocs.io/en/latest/",target:"_blank",rel:"noopener noreferrer"}},[s._v("官方文档"),t("OutboundLink")],1)]),s._v(" "),t("blockquote",[t("p",[s._v("redis 提供两个类 Redis 和 StrictRedis 用于实现 Redis 的命令，StrictRedis 用于实现大部分官方的命令，并使用官方的语法和命令，Redis 是 StrictRedis 的子类，用于向后兼容旧版本的 redis-py。")])]),s._v(" "),t("p",[s._v("可以使用 Redis 可视化工具 "),t("strong",[s._v("RDM(redis deaktop manager)")])]),s._v(" "),t("h2",{attrs:{id:"redis-简述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-简述"}},[s._v("#")]),s._v(" Redis 简述")]),s._v(" "),t("p",[s._v("什么是 Redis？有什么优缺点？")]),s._v(" "),t("ul",[t("li",[s._v("Redis本质上是一个 key-value 类型的内存数据库，整个数据库都在内存中加载，通过异步操作可以持久化到磁盘中")]),s._v(" "),t("li",[s._v("Redis的性能十分出色，是已知的性能最快的 key-value DB(每秒大概处理10W次IO操作)")]),s._v(" "),t("li",[s._v("Redis 拥有丰富的数据结构（5 种，分别是 string, list, hash, set, zset）")]),s._v(" "),t("li",[s._v("Redis 丰富的数据结构给了它很多的应用，如 celery 就可以维护一个高性能的消息队列(list)")]),s._v(" "),t("li",[s._v("不同于 memcached, redis 的单个 value 可以保存的最大数据限制是 1GB(memcached 是 1M)")]),s._v(" "),t("li",[s._v("缺点在于 redis 的数据存储受到物理内存的限制，不能做海量的数据场景")])]),s._v(" "),t("h2",{attrs:{id:"redis-原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-原理"}},[s._v("#")]),s._v(" Redis 原理")]),s._v(" "),t("h2",{attrs:{id:"数据淘汰策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据淘汰策略"}},[s._v("#")]),s._v(" 数据淘汰策略")]),s._v(" "),t("p",[s._v("当达到内存最大限制的时候，Redis 会采用一些策略(maxmemory-policy配置), 来进行数据淘汰：")]),s._v(" "),t("ol",[t("li",[s._v("noeviction：默认策略，不淘汰，达到最大的内存限制的时候，如果再请求更多的数据，直接报错")]),s._v(" "),t("li",[s._v("allkeys-lru：LRU 策略，删除最近最少使用的 key, 针对于所有的key")]),s._v(" "),t("li",[s._v("volatile-lru：设置的 expire 的key使用 LRU")]),s._v(" "),t("li",[s._v("allkeys-random：随机删除一部分key")]),s._v(" "),t("li",[s._v("volatile-random：对设置的 expire 的key随机删除")]),s._v(" "),t("li",[s._v("volatile-ttl：对设置 expire 的key使用，优先删除剩余时间短的key")])]),s._v(" "),t("p",[s._v("对于这六种数据淘汰策略的使用场景可以归纳为：")]),s._v(" "),t("ol",[t("li",[s._v("如果分为热数据和冷数据的场景（所有key中有一部分经常被读写），使用 LRU 方法")]),s._v(" "),t("li",[s._v("如果是循环读所有的 key, 那么就使用 allkeys-random 策略")])]),s._v(" "),t("h2",{attrs:{id:"redis-生产适用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-生产适用场景"}},[s._v("#")]),s._v(" Redis 生产适用场景")]),s._v(" "),t("ol",[t("li",[s._v("session cache 会话缓存\n一般业界使用 memcached, 但是 redis 多了持久化功能，可以维护严格要求一致性的缓存")]),s._v(" "),t("li",[s._v("FPC 全页缓存")]),s._v(" "),t("li",[s._v("redis queues\n如 celery 队列可以使用 redis作为broker")]),s._v(" "),t("li",[s._v("排行榜、计数器\n使用了 redis 中的递增和递减操作")]),s._v(" "),t("li",[s._v("原子操作、事务操作\n事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行；\n事务在执行的过程中不会被其他客户端发送过来的命令打断；\n事务是一个原子操作，事务中的所有命令要么全部被执行，要么全部不执行。\n事务相关的命令："),t("code",[s._v("MULTI, EXEC, DISCARD, WATCH")])])]),s._v(" "),t("h2",{attrs:{id:"redis-优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-优化"}},[s._v("#")]),s._v(" Redis 优化")]),s._v(" "),t("ol",[t("li",[t("p",[s._v("设置key的过期时间\n使用"),t("code",[s._v("expire")]),s._v("命令，如果想要永久有效，那么就使用 "),t("code",[s._v("presist")]),s._v(".")])]),s._v(" "),t("li",[t("p",[s._v("使用散列表\n比如说有一个场景，需要存储用户的账户、密码等信息，尽量不给每一个字段去设置单独的key, 而是将他们一起存储于一张散列表里面。")])])]),s._v(" "),t("h2",{attrs:{id:"redis-分布式锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-分布式锁"}},[s._v("#")]),s._v(" Redis 分布式锁")]),s._v(" "),t("h3",{attrs:{id:"分布式锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[s._v("#")]),s._v(" 分布式锁")]),s._v(" "),t("p",[s._v("分布式的流行使得原单机部署情况下的并发控制策略失效。")]),s._v(" "),t("p",[s._v("分布式锁大致分为三种：")]),s._v(" "),t("ol",[t("li",[s._v("数据库乐观锁")]),s._v(" "),t("li",[s._v("基于 redis 的分布式锁")]),s._v(" "),t("li",[s._v("基于 ZooKeeper 的分布式锁")])]),s._v(" "),t("p",[s._v("分布式锁的实现条件：")]),s._v(" "),t("ol",[t("li",[s._v("互斥性，任何时候只能有一个客户端持有锁")]),s._v(" "),t("li",[s._v("可靠性，尽量避免死锁")]),s._v(" "),t("li",[s._v("一致性，锁只能由加锁人解锁，不能产生A的加锁被B用户解锁的情况")])]),s._v(" "),t("h2",{attrs:{id:"redis-分布式集群"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-分布式集群"}},[s._v("#")]),s._v(" Redis 分布式集群")]),s._v(" "),t("p",[s._v("目前已知的可以通过 proxy 来实现")]),s._v(" "),t("h3",{attrs:{id:"redis-分布式锁-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-分布式锁-2"}},[s._v("#")]),s._v(" Redis 分布式锁")]),s._v(" "),t("p",[s._v("基本上实现如下，主要使用三个命令：")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# SETNX")]),s._v("\nSETNX key val\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# EXPIRE")]),s._v("\nexpire key "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("timeout")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# DELETE")]),s._v("\ndelete key\n")])])]),t("p",[s._v("redis 锁的实现思路基本上是：")]),s._v(" "),t("ol",[t("li",[s._v("setnx加锁，并设置超时时间，这时候锁的 value 值就是一个随机生成的 UUID")]),s._v(" "),t("li",[s._v("获取锁和超时时间")]),s._v(" "),t("li",[s._v("释放锁的时候根据 UUID 判断，而后 DELETE 删除（注意这里要注意原子性）")])]),s._v(" "),t("h3",{attrs:{id:"redis-cluster-槽"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-cluster-槽"}},[s._v("#")]),s._v(" Redis Cluster 槽")]),s._v(" "),t("h2",{attrs:{id:"redis-py"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-py"}},[s._v("#")]),s._v(" redis-py")]),s._v(" "),t("h3",{attrs:{id:"strictredis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#strictredis"}},[s._v("#")]),s._v(" StrictRedis()")]),s._v(" "),t("p",[s._v("初始化 Redis:")]),s._v(" "),t("div",{staticClass:"language-py extra-class"},[t("pre",{pre:!0,attrs:{class:"language-py"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" redis "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" StrictRedis\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("def")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("create_redis_client")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n    redis_client "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" StrictRedis"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("\n            host"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'localhost'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n            port"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("6379")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n            password"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("None")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" redis_client\n")])])]),t("p",[s._v("也可以使用 "),t("code",[s._v("Redis()")]),s._v(" 类初始化，如果遇到了向后兼容的问题。")]),s._v(" "),t("h3",{attrs:{id:"append"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#append"}},[s._v("#")]),s._v(" append()")]),s._v(" "),t("div",{staticClass:"language-py extra-class"},[t("pre",{pre:!0,attrs:{class:"language-py"}},[t("code",[s._v("redis_client"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("append"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("key"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])])]),t("p",[s._v("如果 key 不存在则创建。")])])}),[],!1,null,null,null);e.default=r.exports}}]);