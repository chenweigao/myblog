---
title: "Algorithm of DP: Basic Problems"
date: 2021-11-23
tags:
 - algorithm
categories:
 - Algorithm
---

ğŸš‘ğŸš‘ğŸš‘ é’ˆå¯¹åŠ¨æ€è§„åˆ’ï¼Œæœ¬æ–‡ä¸»è¦è®²è¿°åŠ¨æ€è§„åˆ’åŸºç¡€é—®é¢˜åŠæ±‚è§£ï¼ŒåŒ…æ‹¬ï¼š

1. è®°å¿†åŒ–æœç´¢
2. TODO

<!-- more -->

## è®°å¿†åŒ–æœç´¢

### æ¦‚è§ˆ

è®°å¿†åŒ–æœç´¢å’Œ DP æ˜¯æœ‰å¾ˆå¤šç›¸ä¼¼ä¹‹å¤„çš„ï¼Œæ‰€ä»¥æŠŠè®°å¿†åŒ–æœç´¢æ”¾åœ¨ DP é‡Œé¢è¿›è¡Œç ”ç©¶ã€‚

æ€»çš„æ¥è¯´ï¼Œæˆ‘ä»¬å†™è®°å¿†åŒ–æœç´¢ç®—æ³•çš„æ­¥éª¤å¤§è‡´ä¸ºï¼š

- ä½¿ç”¨BFSè®°å¿†åŒ–ï¼š
  1. å†™å‡ºè¿™é“é¢˜çš„æš´åŠ›æœç´¢ç¨‹åºï¼ˆå¦‚ DFSï¼‰
  2. å°†è¿™ä¸ª DFS æ”¹å†™åŸâ€œæ— éœ€å¤–éƒ¨å˜é‡â€çš„ DFS
  3. æ·»åŠ è®°å¿†åŒ–æ•°ç»„
- ä½¿ç”¨çŠ¶æ€è½¬ç§»æ–¹ç¨‹è®°å¿†åŒ–ï¼š
  1. æŠŠè¿™é“é¢˜ç›®çš„ DP å’Œæ–¹ç¨‹å†™å‡ºæ¥
  2. æ ¹æ®å®ƒä»¬å†™å‡º DFS å‡½æ•°
  3. æ·»åŠ è®°å¿†åŒ–æ•°ç»„

å…¶ä¼˜ç‚¹åœ¨äºï¼š
1. é¿å…æœç´¢åˆ°æ— ç”¨çŠ¶æ€

å…¶ç¼ºç‚¹åœ¨äºï¼š
1. ä¸èƒ½æ»šåŠ¨æ•°ç»„
2. æœ‰äº›ä¼˜åŒ–è¾ƒéš¾
3. æ•ˆç‡è¾ƒä½ä½†æ˜¯ä¸è‡³äº TLE



æœ‰æ—¶å€™ä¼šè§‰å¾—ï¼Œè¿™ä¸ªè®°å¿†åŒ–æœç´¢å’Œ DFS å¾ˆåƒï¼Œä¹Ÿæœ‰ç‚¹èƒŒåŒ…çš„æ„Ÿè§‰ï¼Œä»¥åå†å¥½å¥½ç ”ç©¶ä¸€ä¸‹ã€‚

2021å¹´11æœˆ24æ—¥ï¼šå°±ç›®å‰ç†è§£æ¥è¯´ï¼Œè¿™æ˜¯ä¸€ç§å¾ˆåƒåœ¾çš„ç®—æ³•ã€‚

### LC638 å¤§ç¤¼åŒ…

[638. å¤§ç¤¼åŒ…](https://leetcode-cn.com/problems/shopping-offers/)

è¿™é“é¢˜ç›®å¯ä»¥åˆ©ç”¨è®°å¿†åŒ–æœç´¢çš„æ–¹å¼å»æ±‚è§£ã€‚

é¦–å…ˆæŒ‰ç…§ä¾‹å­è§£é‡Šä¸€ä¸‹è¿™ä¸ªç”¨ä¾‹ï¼š

> price = [2, 5] // A,B å¯¹åº”çš„ä»·æ ¼
>
> special = [[3, 0, 5], [1, 2, 10]] // è¡¨ç¤ºæŠ˜æ‰£, 3A 0B çš„å¤§ç¤¼åŒ…ä»·æ ¼æ˜¯ 5
>
> needs = [3, 2] // éœ€è¦ä¹°çš„æ€»çš„æ•°é‡

1. æˆ‘ä»¬è¯¥æ€ä¹ˆåˆç†ä½¿ç”¨å¤§ç¤¼åŒ…å‘¢ï¼Ÿ

   æŒ‰ç…§è®°å¿†åŒ–æœç´¢çš„æ€è·¯ï¼Œæˆ‘ä»¬é¦–å…ˆè¿‡æ»¤æ‰æ— ç”¨çš„çŠ¶æ€ï¼Œå³è¿‡æ»¤æ‰ä¸éœ€è¦è®¡ç®—çš„å¤§ç¤¼åŒ…ï¼Œå¯ä»¥åˆ†å‡ ç§æƒ…å†µæ¥åˆ¤æ–­å“ªäº›å¤§ç¤¼åŒ…æ˜¯æˆ‘ä»¬ä¸éœ€è¦çš„ï¼š

   - æ ¹æ®é¢˜ç›®è¦æ±‚ã€Œä¸èƒ½è´­ä¹°è¶…å‡ºè´­ç‰©æ¸…å•æŒ‡å®šæ•°é‡çš„ç‰©å“ã€ï¼Œå¦‚æœå¤§ç¤¼åŒ…é‡Œé¢çš„æ‰€æœ‰ç‰©å“åŠ èµ·æ¥è¶…è¿‡æˆ‘ä»¬è¦ä¹°çš„ç‰©å“æ€»æ•°äº†ï¼Œé‚£ä¹ˆè¿™ä¸ªå¤§ç¤¼åŒ…ä¸èƒ½è¦ï¼›
   - å¤§ç¤¼åŒ…ä¸åˆ’ç®—åˆ™ä¸é€‰è¿™ä¸ªå¤§ç¤¼åŒ…ï¼ˆä¸åˆ’ç®—æŒ‡çš„æ˜¯æˆ‘å•ç‹¬ä¹°è¿™äº›ç‰©å“ï¼Œä¸‹æ¥å¤§ç¤¼åŒ…åè€Œè´µäº†ï¼‰
   - å¤§ç¤¼åŒ…å†…ä¸åŒ…å«æˆ‘ä»¬è¦ä¹°çš„ç‰©å“ï¼Œä¹Ÿä¸èƒ½ä¹° 

   ä»¥ä¸Šçš„æ¡ä»¶å°±æ˜¯æˆ‘ä»¬è®°å¿†åŒ–æœç´¢æ—¶å¯ä»¥ç”¨æ¥ç­›é€‰çš„æ¡ä»¶ã€‚

2. æ ¹æ®é¢˜ç›®è¦æ±‚ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºå¤§è‡´çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€‚

   - æˆ‘ä»¬ç”¨ `dp `è¡¨ç¤ºæ»¡è¶³è´­ç‰©æ¸…å• `needs `éœ€è¦çš„æœ€å°èŠ±è´¹

   - æˆ‘ä»¬æ€è€ƒæ»¡è¶³è´­ç‰©æ¸…å• `needs `çš„æœ€åä¸€æ¬¡è´­ä¹°ï¼Œå…¶å¯ä»¥åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š
     1. è´­ä¹°å¤§ç¤¼åŒ…
     2. ä¸è´­ä¹°å¤§ç¤¼åŒ…
   - æˆ‘ä»¬å¦‚æœè´­ä¹°å¤§ç¤¼åŒ…çš„æ—¶å€™ï¼Œå¯ä»¥éå†æ¯ä¸€ä¸ªå¤§ç¤¼åŒ…ï¼Œ$price_i$ è¡¨ç¤ºç¬¬ $i$ ä¸ªå¤§ç¤¼åŒ…çš„ä»·æ ¼ï¼Œ$needs_i$ è¡¨ç¤ºå¤§ç¤¼åŒ…ä¸­çš„ç‰©å“æ¸…å•ï¼Œ$needs - needs_i$ è¡¨ç¤ºè´­ç‰©æ¸…å• $needs$ å‡å»ç¬¬ $i$ ä¸ªå¤§ç¤¼åŒ…ä¸­åŒ…å«çš„ç‰©å“æ¸…å•åå‰©ä½™çš„ç‰©å“æ¸…å•ã€‚

å…ˆé™„ä¸Šå®˜æ–¹é¢˜è§£ï¼Œè¿™ä¸ªé¢˜è§£ç›®å‰è¿˜æœ‰å¾ˆå¤šçš„ç–‘é—®ç‚¹ï¼š

```python
class Solution:
    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:
        n = len(price)
        filter_special = []
        for sp in special:
            # æ¯”å¦‚åœ¨ç¬¬ä¸€ä¸ªä¾‹å­ä¸­ i == 2
            # ç¬¬äºŒä¸ªæ¡ä»¶è¡¨ç¤ºå¤§ç¤¼åŒ…æ˜¯æœ‰ä¼˜æƒ çš„ï¼Œè¿™æ—¶å€™æˆ‘ä»¬é€‰æ‹©è¯¥ç¤¼åŒ…
            if sum(sp[i] for i in range(n)) > 0 and sum(sp[i] * price[i] for i in range(n)) > sp[-1]:
                filter_special.append(sp)

        @lru_cache(None)
        def dfs(cur_needs):
            # åœ¨ä¸è´­ä¹°å¤§ç¤¼åŒ…çš„æ—¶å€™ï¼Œè´­ä¹°è´­ç‰©æ¸…å•ä¸­æ‰€æœ‰ç‰©å“éœ€è¦çš„èŠ±è´¹
            min_price = sum(need * price[i] for i, need in enumerate(cur_needs))
            for cur_special in filter_special:
                special_price = cur_special[-1]
                nxt_needs = []
                for i in range(n):
                    if cur_special[i] > cur_needs[i]:
                        # ä¸è´­ä¹°å¤šäºå½“å‰è®¢å•æ•°é‡çš„ç‰©å“
                        break
                    # è¿˜å‰©ä¸‹å¤šå°‘ç‰©å“éœ€è¦è´­ä¹°
                    nxt_needs.append(cur_needs[i] - cur_special[i])
                # why, å¦‚æœä¸Šè¿°éå†å®Œæˆï¼Œæ»¡è¶³æ•°é‡æ¡ä»¶ï¼Œå¤§ç¤¼åŒ…å¯ä»¥è´­ä¹°
                if len(nxt_needs) == n:
                    min_price = min(min_price, dfs(tuple(nxt_needs)) + special_price)

            return min_price

        return dfs(tuple(needs))
```

å¯¹åº”çš„æµ‹è¯•ç”¨ä¾‹ï¼š

```python
class Test(unittest.TestCase):
    def setUp(self) -> None:
        self.s = Solution()

    def test_1(self):
        # æŠ˜æ‰£å¯¹åº”çš„ä»·æ ¼
        price = [2, 5]
        # è¡¨ç¤ºæŠ˜æ‰£
        special = [[3, 0, 5], [1, 2, 10]]
        # éœ€è¦ä¹°çš„æ•°é‡
        needs = [3, 2]

        res = self.s.shoppingOffers(price, special, needs)
        self.assertEqual(14, res)
```

é’ˆå¯¹ä¸Šé¢çš„ç–‘ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥å‚è€ƒèƒŒåŒ…é—®é¢˜ä¸­çš„ç»å…¸èƒŒåŒ…é—®é¢˜ï¼ŒåŠ æ·±ç†è§£ï¼Œç„¶åå†å¯»æ±‚æ±‚è§£æ–¹å¼ã€‚

### P1048 [NOIP2005 æ™®åŠç»„] é‡‡è¯

> è¾°è¾°æ˜¯ä¸ªå¤©èµ„èªé¢–çš„å­©å­ï¼Œä»–çš„æ¢¦æƒ³æ˜¯æˆä¸ºä¸–ç•Œä¸Šæœ€ä¼Ÿå¤§çš„åŒ»å¸ˆã€‚ä¸ºæ­¤ï¼Œä»–æƒ³æ‹œé™„è¿‘æœ€æœ‰å¨æœ›çš„åŒ»å¸ˆä¸ºå¸ˆã€‚åŒ»å¸ˆä¸ºäº†åˆ¤æ–­ä»–çš„èµ„è´¨ï¼Œç»™ä»–å‡ºäº†ä¸€ä¸ªéš¾é¢˜ã€‚åŒ»å¸ˆæŠŠä»–å¸¦åˆ°ä¸€ä¸ªåˆ°å¤„éƒ½æ˜¯è‰è¯çš„å±±æ´é‡Œå¯¹ä»–è¯´ï¼šâ€œå­©å­ï¼Œè¿™ä¸ªå±±æ´é‡Œæœ‰ä¸€äº›ä¸åŒçš„è‰è¯ï¼Œé‡‡æ¯ä¸€æ ªéƒ½éœ€è¦ä¸€äº›æ—¶é—´ï¼Œæ¯ä¸€æ ªä¹Ÿæœ‰å®ƒè‡ªèº«çš„ä»·å€¼ã€‚æˆ‘ä¼šç»™ä½ ä¸€æ®µæ—¶é—´ï¼Œåœ¨è¿™æ®µæ—¶é—´é‡Œï¼Œä½ å¯ä»¥é‡‡åˆ°ä¸€äº›è‰è¯ã€‚å¦‚æœä½ æ˜¯ä¸€ä¸ªèªæ˜çš„å­©å­ï¼Œä½ åº”è¯¥å¯ä»¥è®©é‡‡åˆ°çš„è‰è¯çš„æ€»ä»·å€¼æœ€å¤§ã€‚â€
>
> å¦‚æœä½ æ˜¯è¾°è¾°ï¼Œä½ èƒ½å®Œæˆè¿™ä¸ªä»»åŠ¡å—ï¼Ÿ
>

å…ˆç»™å‡ºæµ‹è¯•ä»£ç ï¼š

```python
class Test(unittest.TestCase):
    def setUp(self) -> None:
        self.s = Solution()

    def test_1(self):
        costs = [71, 69, 1]
        values = [100, 1, 2]
        res = self.s.solution(costs, values)
        self.assertEqual(3, res)
```

æˆ‘ä»¬åœ¨è¿™ä¸ªæ–‡ç« ä¸­ç ”ç©¶è®°å¿†åŒ–æœç´¢ï¼Œæ‰€ä»¥è€ƒè™‘è¿™ä¸ªé—®é¢˜ï¼Œé¦–å…ˆæŒ‰ç…§**æš´åŠ›æœç´¢**çš„æ€è·¯å»è§£å†³ã€‚âŒâŒâŒ è¿™ä¸ªç›®å‰æ°´å¹³ä¸è¶³ï¼Œåç»­å¾…å®šã€‚

æˆ‘ä»¬ç»™å‡ºæ±‚è§£è¿™ä¸ªé—®é¢˜çš„ä»£ç ï¼ŒæŒ‰ç…§ç»å…¸çš„èƒŒåŒ…é—®é¢˜æ¥æ±‚è§£ã€‚

```python
import unittest

import numpy as np


class Solution:
    def solution(self, weights, values, size):
        if not size:
            return 0

        n = len(weights)
        # æˆ‘ä»¬å®šä¹‰ dp æ•°ç»„ dp[i][w], å¯¹äºå‰ i ä¸ªç‰©å“ï¼Œå½“å‰èƒŒåŒ…å®¹é‡ä¸º wï¼Œå¯ä»¥è£…çš„æœ€å¤§ä»·å€¼æ˜¯ dp[i][w]
        # dp = [[0] * (size + 1) for _ in range(n)]
        dp = np.zeros(shape=(n, size + 1))
        # å¾ªç¯ä¸­éå†ç‰©å“
        for i in range(1, n):
            # å†…å±‚å¾ªç¯éå†èƒŒåŒ…å®¹é‡
            # for j in range(size + 1) ç­‰åŒ
            for j in range(size, weights[i] - 1, -1):
                # å½“å‰èƒŒåŒ…è£…ä¸ä¸‹
                if weights[i] > j:
                    dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weights[i]] + values[i])
        return dp[n - 1][size]
```

ä¸€ç»´ DP å¥—ç”¨å…¬å¼çš„è§£æ³•ï¼š

```python
    def solution2(self, weights, values, size):
        if not size:
            return 0

        # æˆ‘ä»¬æ‹¿å®¹é‡å»å®šä¹‰ dp
        dp = [0] + [0] * size

        # æŒ‰ç…§èƒŒåŒ…é—®é¢˜çš„å¥—è·¯ï¼Œéå†ç‰©å“
        for idx, weight in enumerate(weights):
            for i in range(size, weight - 1, -1):
                dp[i] = max(dp[i], dp[i - weight] + values[idx])

        return dp[-1]
```



### LC329 çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„

[329. çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

- ç”±äºåŒä¸€ä¸ªå•å…ƒæ ¼å¯¹åº”çš„æœ€é•¿é€’å¢è·¯å¾„çš„é•¿åº¦æ˜¯å›ºå®šä¸å˜çš„ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨è®°å¿†åŒ–çš„æ–¹æ³•è¿›è¡Œä¼˜åŒ–ï¼›
- ç”¨çŸ©é˜µä½œä¸ºç¼“å­˜çŸ©é˜µï¼Œå·²ç»è®¡ç®—è¿‡çš„å•å…ƒæ ¼çš„ç»“æœå­˜å‚¨åˆ°ç¼“å­˜çŸ©é˜µä¸­ã€‚ï¼ˆåœ¨pythonä¸­ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ `@lru_cache(None)`, å®ç°è¾ƒä¸ºç®€å•ï¼‰

è®°å¿†åŒ–æœç´¢å®ç°å¦‚ä¸‹ï¼š

```python
class Solution:
    def __init__(self, *args, **kwargs):
        self.dirs = [
            [0, 1], [1, 0], [0, -1], [-1, 0]
        ]
        self.m = None
        self.n = None

    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        self.m = len(matrix)
        self.n = len(matrix[0])
        ans = 0

        memo = [[0] * self.n for _ in range(self.m)]

        def dfs(i, j):
            if memo[i][j] != 0:
                return memo[i][j]

            memo[i][j] = 1
            for d in self.dirs:
                x, y = d[0] + i, d[1] + j
                if 0 <= x < self.m and 0 <= y < self.n and matrix[x][y] > matrix[i][j]:
                    memo[i][j] = max(memo[i][j], dfs(x, y) + 1)
            return memo[i][j]

        for i in range(self.m):
            for j in range(self.n):
                if memo[i][j] != 0:
                    ans = max(ans, memo[i][j])
                else:
                    ans = max(ans, dfs(i, j))
        return ans
```



