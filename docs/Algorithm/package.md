---
title:  背包问题总结
date: 2021-5-22
tags:
 - algorithm
categories:
 - Algorithm
---

## 概览

背包问题可以大致分为三类，分别是：

1. 背包组合问题
2. True/False 问题
3. 最大最小问题

其基础的背包问题一般由两个模型演变而来：

1. 0-1 背包问题
2. 完全背包问题

本文先研究 0-1 背包和完全背包，而后对其他问题进行研究。

## 0-1 背包

0-1 背包问题比较简单，其特点是每种物品仅有一件，可以选择放或者不放。求解将哪些物品装入背包可使价值总和最大。

### 递推公式

$F(i, v)$ 是前 $i$ 件物品恰放入一个容量为 $v$ 的背包可以获得的最大价值，其状态转移方程如下所示：
$$
F[i,v] = max(f[i-1, v], f[i-1, v-C_i] + W_i)
$$
这个递推公式表示在只考虑 **将第 $i$ 件物品放入容量为 $v$ 的背包中** 这个子问题，可以包含两种情况：

1. 不放第 $i$ 件物品，问题等价于 **前 $i-1$ 件物品放入容量为 $v$ 的背包中**；
   1. 放第 $i$ 件物品，问题等价于 **前 $i-1$ 件物品放入剩下容量为 $v - C_i$ 的背包中，再加上放第 $i$ 件物品的重量 $W_i$**

### 例题 LC474

#### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

>  问题分析：给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。请你找出并返回 `strs` 的最大子集的大小，该子集中最多有 `m` 个 `0` 和 `n` 个 `1` 。如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 子集 。
>
> 输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
> 输出：4
> 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
> 其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。

初看这道题较难理解，需要翻译一下，给定 `m` 和 `n`，表示背包中最多有 5 个 0 和 3 个 1 -- target，要求是子集，则表示不能重复选 -- 0-1 背包。

这就是 **最大最小值的 0-1 背包问题**。

求解代码如下所示，掌握几个关键点：

1. **0-1 背包倒着循环**。为什么要倒着循环？这是因为我们的递推公式中使用到了 $i-1$ 这个中间状态，倒着循环能够保证在推 $F[i,v]$ 的时候能够取用 $F[i-1, v]$  的值。
2. 背包问题外层循环物体、内层循环容量。
3. 最大最小问题的递推公式。
4. 状态转移数组初始化的时候初始化为 0

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        if not strs:
            return 0
         dp = [[0] * (n + 1) for _ in range(m + 1)]

        # 遍历 nums
        for s in strs: 
            zero = s.count('0')
            one = s.count('1')
            # 0-1 背包从后往前
            for i in range(m, zero - 1, -1):
                for j in range(n, one - 1, -1):
                    dp[i][j] = max(dp[i][j], dp[i - zero][j - one] + 1)

        return dp[m][n] 
```

总结来说，这道题目并不是最典型的 0 - 1 背包问题，普通的 0-1 背包问题只有一种容量，但是该背包问题存在 0 和 1 两种容量，每个物品（字符串）均需要分别占用 0 和 1 的若干容量，并且所有物品的价值均为 1。是一个较为典型的二维动态规划问题。

上述代码是经过了状态压缩后的结果，如果不考虑状态压缩的话，可以定义三维 dp，state: `dp[i][j][k]`，i 可以表示选择的物品为前 i 个，j 和 k 分别表示背包 0 和背包 1 的数量限制。在递推过程中，最外循环 i 对应的最新的值，`dp[i][j][k] = max(dp[i-1][j-zeros][k-ones]+1, dp[i-1][j][k])`，将第一维压缩后便得到和代码相同的递推公式。

对比而言，0-1 一维背包的实现方式是：

```python
def zero_one_pack(F, C, W):
    # 倒着来
    for v <- V to C:
        F[v] <- max(F[v], F[v - C] + W)
```

其中 C 表示某个物体的容量，W 表示其价值。

0-1 背包的伪代码可以为：

```python
F[0..V] <- 0
for i <- 1 to N
	zero_one_pack(Fi, Ci, Wi)
```



