```
---
title:  背包问题总结
date: 2019-8-6
tags:
 - algorithm
categories:
 - Algorithm
---
```

## 概览

背包问题可以大致分为三类，分别是：

1. 背包组合问题
2. True/False 问题
3. 最大最小问题

其基础的背包问题一般由两个模型演变而来：

1. 0-1 背包问题
2. 完全背包问题

本文先研究 0-1 背包和完全背包，而后对其他问题进行研究。

## 0-1 背包

0-1 背包问题比较简单，其特点是每种物品仅有一件，可以选择放或者不放。求解将哪些物品装入背包可使价值总和最大。

### 递推公式

$F(i, v)$ 是前 $i$ 件物品恰放入一个容量为 $v$ 的背包可以获得的最大价值，其状态转移方程如下所示：
$$
F[i,v] = max(f[i-1, v], f[i-1, v-C_i] + W_i)
$$
这个递推公式表示在只考虑**将第 $i$ 件物品放入容量为 $v$ 的背包中**这个子问题，可以包含两种情况：

1. 不放第 $i$ 件物品，问题等价于**前 $i-1$ 件物品放入容量为 $v$ 的背包中**；
   1. 放第 $i$ 件物品，问题等价于 **前 $i-1$ 件物品放入剩下容量为 $v - C_i$ 的背包中，再加上放第 $i$ 件物品的重量 $W_i$**

### 例题 LC474

#### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

>  问题分析：给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。请你找出并返回 `strs` 的最大子集的大小，该子集中最多有 `m` 个 `0` 和 `n` 个 `1` 。如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 子集 。
>
> ```md
> 输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
> 输出：4
> 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
> 其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
> ```

初看这道题较难理解，需要翻译一下，给定 `m` 和 `n`，表示背包中最多有 5 个 0 和 3 个 1 -- target，要求是子集，则表示不能重复选 -- 0-1 背包。

这就是**最大最小值的 0-1 背包问题**。

求解代码如下所示，掌握几个关键点：

1. **0-1 背包倒着循环**。为什么要倒着循环？这是因为我们的递推公式中使用到了 $i-1$ 这个中间状态，倒着循环能够保证在推 $F[i,v]$ 的时候能够取用 $F[i-1, v]$  的值。
2. 最大最小问题的递推公式。
3. 状态转移数组初始化的时候初始化为 0

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        if not strs:
            return 0
         dp = [[0] * (n + 1) for _ in range(m + 1)]

        # 遍历 nums
        for s in strs: 
            zero = s.count('0')
            one = s.count('1')
            # 0-1 背包从后往前
            for i in range(m, zero - 1, -1):
                for j in range(n, one - 1, -1):
                    dp[i][j] = max(dp[i][j], dp[i - zero][j - one] + 1)

        return dp[m][n] 
```





