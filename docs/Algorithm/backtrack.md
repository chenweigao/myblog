---
title: Algorithm of Back Track
date: 2021-10-15
tags:
 - algorithm
categories:
 - Algorithm
---



**å›æº¯æ³•**ï¼ˆè‹±è¯­ï¼šbacktrackingï¼‰æ˜¯[æš´åŠ›æœç´¢æ³•](https://zh.wikipedia.org/wiki/æš´åŠ›æœå°‹æ³•)ä¸­çš„ä¸€ç§ã€‚

å¯¹äºæŸäº›è®¡ç®—é—®é¢˜è€Œè¨€ï¼Œå›æº¯æ³•æ˜¯ä¸€ç§å¯ä»¥æ‰¾å‡ºæ‰€æœ‰ï¼ˆæˆ–ä¸€éƒ¨åˆ†ï¼‰è§£çš„ä¸€èˆ¬æ€§ç®—æ³•ï¼Œå°¤å…¶é€‚ç”¨äº[çº¦æŸè¡¥å¿é—®é¢˜](https://zh.wikipedia.org/wiki/çº¦æŸè¡¥å¿é—®é¢˜)ï¼ˆåœ¨è§£å†³çº¦æŸæ»¡è¶³é—®é¢˜æ—¶ï¼Œæˆ‘ä»¬é€æ­¥æ„é€ æ›´å¤šçš„å€™é€‰è§£ï¼Œå¹¶ä¸”åœ¨ç¡®å®šæŸä¸€éƒ¨åˆ†å€™é€‰è§£ä¸å¯èƒ½è¡¥å…¨æˆæ­£ç¡®è§£ä¹‹åæ”¾å¼ƒç»§ç»­æœç´¢è¿™ä¸ªéƒ¨åˆ†å€™é€‰è§£æœ¬èº«åŠå…¶å¯ä»¥æ‹“å±•å‡ºçš„å­å€™é€‰è§£ï¼Œè½¬è€Œæµ‹è¯•å…¶ä»–çš„éƒ¨åˆ†å€™é€‰è§£ï¼‰ã€‚

<!-- more -->

åœ¨ç»å…¸çš„æ•™ç§‘ä¹¦ä¸­ï¼Œ[å…«çš‡åé—®é¢˜](https://zh.wikipedia.org/wiki/å…«çš‡åé—®é¢˜)å±•ç¤ºäº†å›æº¯æ³•çš„ç”¨ä¾‹ã€‚ï¼ˆå…«çš‡åé—®é¢˜æ˜¯åœ¨æ ‡å‡†å›½é™…è±¡æ£‹æ£‹ç›˜ä¸­å¯»æ‰¾å…«ä¸ªçš‡åçš„æ‰€æœ‰åˆ†å¸ƒï¼Œä½¿å¾—æ²¡æœ‰ä¸€ä¸ªçš‡åèƒ½æ”»å‡»åˆ°å¦å¤–ä¸€ä¸ªã€‚ï¼‰

å›æº¯æ³•é‡‡ç”¨[è¯•é”™](https://zh.wikipedia.org/wiki/è¯•é”™)çš„æ€æƒ³ï¼Œå®ƒå°è¯•åˆ†æ­¥çš„å»è§£å†³ä¸€ä¸ªé—®é¢˜ã€‚åœ¨åˆ†æ­¥è§£å†³é—®é¢˜çš„è¿‡ç¨‹ä¸­ï¼Œå½“å®ƒé€šè¿‡å°è¯•å‘ç°ï¼Œç°æœ‰çš„åˆ†æ­¥ç­”æ¡ˆä¸èƒ½å¾—åˆ°æœ‰æ•ˆçš„æ­£ç¡®çš„è§£ç­”çš„æ—¶å€™ï¼Œå®ƒå°†å–æ¶ˆä¸Šä¸€æ­¥ç”šè‡³æ˜¯ä¸Šå‡ æ­¥çš„è®¡ç®—ï¼Œå†é€šè¿‡å…¶å®ƒçš„å¯èƒ½çš„åˆ†æ­¥è§£ç­”å†æ¬¡å°è¯•å¯»æ‰¾é—®é¢˜çš„ç­”æ¡ˆã€‚å›æº¯æ³•é€šå¸¸ç”¨æœ€ç®€å•çš„[é€’å½’](https://zh.wikipedia.org/wiki/é€’å½’)æ–¹æ³•æ¥å®ç°ï¼Œåœ¨åå¤é‡å¤ä¸Šè¿°çš„æ­¥éª¤åå¯èƒ½å‡ºç°ä¸¤ç§æƒ…å†µï¼š

- æ‰¾åˆ°ä¸€ä¸ªå¯èƒ½å­˜åœ¨çš„æ­£ç¡®çš„ç­”æ¡ˆ
- åœ¨å°è¯•äº†æ‰€æœ‰å¯èƒ½çš„åˆ†æ­¥æ–¹æ³•åå®£å‘Šè¯¥é—®é¢˜æ²¡æœ‰ç­”æ¡ˆ

åœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œå›æº¯æ³•ä¼šå¯¼è‡´ä¸€æ¬¡[å¤æ‚åº¦](https://zh.wikipedia.org/wiki/è®¡ç®—å¤æ‚æ€§ç†è®º)ä¸º[æŒ‡æ•°æ—¶é—´](https://zh.wikipedia.org/wiki/æŒ‡æ•¸æ™‚é–“)çš„è®¡ç®—ã€‚

## å›æº¯ï¼šæ¨¡æ¿

æ€»ç»“å›æº¯çš„æ¨¡æ¿å¦‚ä¸‹ï¼š

```python
result = []
def back_track(path, choices):
    if OK:
        result.append(path)
        return
    else:
        for choice in choices:
            make_choices()
            back_tarack(path, choices)
            undo_choices()
```

å…¶ä¸­ path è¡¨ç¤ºè·¯å¾„ï¼Œchoices è¡¨ç¤ºåšå‡ºçš„é€‰æ‹©ã€‚

## ä¾‹é¢˜è§£æ - æ’åˆ—ç»„åˆç±»

### LC17 ç”µè¯å·ç çš„å­—æ¯ç»„åˆ

> ç»™å®šä¸€ä¸ªä»…åŒ…å«æ•°å­—Â 2-9Â çš„å­—ç¬¦ä¸²ï¼Œè¿”å›æ‰€æœ‰å®ƒèƒ½è¡¨ç¤ºçš„å­—æ¯ç»„åˆã€‚ç­”æ¡ˆå¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ã€‚
>
> ç»™å‡ºæ•°å­—åˆ°å­—æ¯çš„æ˜ å°„å¦‚ä¸‹ï¼ˆä¸ç”µè¯æŒ‰é”®ç›¸åŒï¼‰ã€‚æ³¨æ„ 1 ä¸å¯¹åº”ä»»ä½•å­—æ¯ã€‚
>
> è¾“å…¥ï¼šdigits = "23"
>
> è¾“å‡ºï¼š["ad","ae","af","bd","be","bf","cd","ce","cf"]
>
> æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
> 
> é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/letter-combinations-of-a-phone-number
> è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

è§£æ³•ï¼šæ ‡å‡†å›æº¯ï¼š

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return list()

        dig2alph = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }

        def back_track(index):
            if index == len(digits):
                res.append(''.join(combination))
            else:
                digit = digits[index]
                for ch in dig2alph[digit]:
                    combination.append(ch)
                    back_track(index + 1)
                    combination.pop()

        combination = list()
        res = list()
        back_track(0)
        return res
```

### LC22 æ‹¬å·ç”Ÿæˆ

>æ•°å­— `n` ä»£è¡¨ç”Ÿæˆæ‹¬å·çš„å¯¹æ•°ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºèƒ½å¤Ÿç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„å¹¶ä¸” **æœ‰æ•ˆçš„** æ‹¬å·ç»„åˆã€‚
>
>æœ‰æ•ˆæ‹¬å·ç»„åˆéœ€æ»¡è¶³ï¼šå·¦æ‹¬å·å¿…é¡»ä»¥æ­£ç¡®çš„é¡ºåºé—­åˆã€‚

è§£æ³•ï¼šå›æº¯ã€‚é€šè¿‡ left å’Œ right æ˜¯å¦"å¹³è¡¡"æ¥ç­›é€‰ä¸€ä¸‹æ•°æ®ã€‚

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []

        def back_track(A: list, left, right):
            # æ¯”å¦‚ n == 3 æ—¶ï¼Œç”Ÿæˆçš„æ‹¬å·æ€»æ•°ä¸º 2*3 ä¸ª
            if len(A) == 2 * n:
                res.append(''.join(A))
                return
            if left < n:
                A.append('(')
                back_track(A, left + 1, right)
                A.pop()
            if right < left:
                A.append(')')
                back_track(A, left, right + 1)
                A.pop()

        back_track([], 0, 0)
        return res
```

å¦‚æœä¸ä½¿ç”¨è¯¥æ–¹æ³•çš„è¯ï¼Œå¯èƒ½éœ€è¦ä½¿ç”¨è¾ƒä¸ºâ€œæš´åŠ›â€çš„è§£æ³•ï¼š
(ä¸è¿‡è¯¥è§£æ³•æ¯”è¾ƒé€‚åˆç”¨æ¥ç†è§£å›æº¯çš„æ€æƒ³)

```python
    def generateParenthesis(self, n: int) -> List[str]:

        def generate(A: list):
            if len(A) == 2 * n:
                if is_valid(A):
                    res.append("".join(A))
            else:
                A.append('(')
                generate(A)
                A.pop()
                A.append(')')
                generate(A)
                A.pop()

        def is_valid(A):
            balance = 0
            for ch in A:
                if ch == '(':
                    balance += 1
                else:
                    balance -= 1
                if balance < 0:
                    return False
            return balance == 0

        res = list()
        generate([])
        return res
```

### LC39 ç»„åˆæ€»æ•°

>ç»™å®šä¸€ä¸ªæ— é‡å¤å…ƒç´ çš„æ­£æ•´æ•°æ•°ç»„ candidates å’Œä¸€ä¸ªæ­£æ•´æ•° target ï¼Œæ‰¾å‡º candidates ä¸­æ‰€æœ‰å¯ä»¥ä½¿æ•°å­—å’Œä¸ºç›®æ ‡æ•° target çš„å”¯ä¸€ç»„åˆã€‚
>
>candidates ä¸­çš„æ•°å­—å¯ä»¥æ— é™åˆ¶é‡å¤è¢«é€‰å–ã€‚å¦‚æœè‡³å°‘ä¸€ä¸ªæ‰€é€‰æ•°å­—æ•°é‡ä¸åŒï¼Œåˆ™ä¸¤ç§ç»„åˆæ˜¯å”¯ä¸€çš„ã€‚ 
>
>è¾“å…¥: candidates = [2,3,6,7], target = 7
>
>è¾“å‡º: [[7],[2,2,3]]
>
>æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
>é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/combination-sum
>è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

å¥—ç”¨ä¸Šè¿°çš„å…¬å¼ï¼Œå†™å‡ºçš„è§£æ³•å¦‚ä¸‹ï¼š

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []

        def back_track(A):
            if sum(A) == target and sorted(A) not in res:
                res.append(sorted(A[:]))
                return
            if sum(A) > target:
                return
            for c in candidates:
                A.append(c)
                back_track(A)
                A.pop()

        back_track([])
        return res
```

æ³¨æ„åˆ° sum(A) å¤§äº target è¢«å‰ªæï¼Œè¿™æ ·å°±å‡å°‘äº†è®¡ç®—é‡ã€‚ç¬¬äºŒæ˜¯é€šè¿‡æ’åºçš„æ“ä½œç­›é€‰å‡ºäº†å·²ç»å­˜åœ¨çš„ç»„åˆã€‚

ä½†æ˜¯è¯¥ç®—æ³•è¿˜å­˜åœ¨å¾ˆå¤§çš„ä¼˜åŒ–ç‚¹ï¼Œå› ä¸ºæˆ‘ä»¬çš„â€œå‰ªæâ€æ“ä½œè¿‡äºåŸå§‹ï¼Œåœ¨è¿™ç§**ä¸éœ€è¦è€ƒè™‘é¡ºåº**çš„é¢˜ç›®ä¸­ï¼Œåº”å½“è€ƒè™‘æ›´åŠ é«˜æ•ˆçš„æ–¹æ³•ã€‚

```python
class Solution2:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []

        def back_track(A: list, cur_sum, begin):
            if cur_sum == target:
                res.append(sorted(A[:]))
                return
            if cur_sum > target:
                return
            for i in range(begin, len(candidates)):
                # å‰ªæ
                if cur_sum + candidates[i] > target:
                    return

                cur_sum += candidates[i]
                A.append(candidates[i])
                // ä¸ç”¨i+1ï¼Œè¡¨ç¤ºå¯ä»¥é‡å¤è¯»å–å½“å‰çš„æ•°
                back_track(A, cur_sum, i)
                cur_sum -= candidates[i]
                A.pop()
        candidates.sort()
        back_track([], 0, 0)
        return res
```

æ³¨æ„åˆ°è¿™ä¸ªå›æº¯ä¹‹å‰æˆ‘ä»¬å…ˆè¿›è¡Œäº†æ’åº`candidates.sort()`,è¿™ä¸ªå‰ªæç›¸æ¯”äºä¸Šé¢çš„è§£æ³•é«˜æ˜ä¹‹å¤„åœ¨å“ªé‡Œå‘¢ï¼Ÿ

- å¦‚æœé¢˜ç›®è¦æ±‚ï¼Œç»“æœé›†ä¸è®¡ç®—é¡ºåºï¼Œæ­¤æ—¶éœ€è¦æŒ‰é¡ºåºæœç´¢ï¼Œæ‰èƒ½åšåˆ°ä¸é‡ä¸æ¼ã€‚ï¼ˆä¸ºä½•æ’åºï¼ŸæŒ‰ç…§ç‰¹å®šæœç´¢æŒ‡å®šäº† `begin`ï¼‰
- ä½¿ç”¨äº†ä¸€ä¸ª `begin`å˜é‡ï¼Œè¿™ä¸ªå˜é‡ç”¨äºç»„åˆé—®é¢˜ï¼Œä¸è®²ç©¶é¡ºåºï¼ˆå³ `[2, 2, 3]` ä¸ `[2, 3, 2]` è§†ä¸ºç›¸åŒåˆ—è¡¨æ—¶ï¼‰ï¼Œéœ€è¦æŒ‰ç…§æŸç§é¡ºåºæœç´¢ã€‚

ç†è§£ `cur_sum`çš„ä¼˜ç‚¹åœ¨äºï¼šå¯¹äºåˆšå¼€å§‹çš„åŸå§‹è§£æ³•ï¼Œï¼Œå¯¹äºsumå·²ç»å¤§äºtargetçš„æƒ…å†µï¼Œå…¶å®æ˜¯ä¾ç„¶è¿›å…¥äº†ä¸‹ä¸€å±‚é€’å½’ï¼Œåªæ˜¯ä¸‹ä¸€å±‚é€’å½’ç»“æŸåˆ¤æ–­çš„æ—¶å€™ï¼Œä¼šåˆ¤æ–­sum > targetçš„è¯å°±è¿”å›ã€‚å…¶å®å¦‚æœå·²ç»çŸ¥é“ä¸‹ä¸€å±‚çš„sumä¼šå¤§äºtargetï¼Œå°±æ²¡æœ‰å¿…è¦è¿›å…¥ä¸‹ä¸€å±‚é€’å½’äº†ã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨ for å¾ªç¯ä¸­åšäº†æ–‡ç« ï¼Œä½¿ç”¨ `cur_sum`æ¥åˆ¤æ–­å¦‚æœä¸‹ä¸€å±‚çš„ sum å·²ç»å¤§äº targetï¼Œå°±æ²¡æœ‰å¿…è¦èµ°ä¸‹å»äº†ï¼Œè€Œæ˜¯ç›´æ¥ç»“æŸæœ¬è½® for å¾ªç¯çš„éå†ã€‚

å‚è€ƒè¯¥[blog](https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html#%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96)

### LC40 ç»„åˆæ€»æ•°II

ä¸åŒäº LC39 ç»„åˆæ€»æ•°ï¼ŒLC40 è¦æ±‚`candidates` ä¸­çš„æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚

ä¸¾ä¾‹è€Œè¨€ï¼š

>è¾“å…¥: candidates = [10,1,2,7,6,1,5], target = 8,
>
>è¾“å‡º:
>[
>[1,1,6],
>[1,2,5],
>[1,7],
>[2,6]
>]
>
>æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
>é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/combination-sum-ii
>è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

é¢˜ç›®çš„æ„æ€æ˜¯ï¼Œæ¯ä¸ªæ•°å­—åœ¨æ¯ä¸€ä¸ªç­”æ¡ˆé‡Œé¢åªèƒ½ç”¨ä¸€æ¬¡ï¼Œæ— æ³•é‡å¤ä½¿ç”¨ï¼Œå› æ­¤å¦‚ä½•è¾¾åˆ°è¿™ä¸ªé™åˆ¶æ˜¯æœ¬é¢˜ç›®çš„éš¾ç‚¹ï¼Œè§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨æ¯”è¾ƒé«˜çº§çš„å‰ªæï¼Œä¸ä¸Šè¿°é¢˜ç›®åªæœ‰ä¸€ç‚¹ä¸åŒï¼Œå…·ä½“çœ‹ä»£ç ï¼š

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []

        def back_track(A: list, cur_sum, begin):
            if cur_sum == target:
                res.append(A[:])
                return
            if cur_sum > target:
                return

            for i in range(begin, len(candidates)):
                if cur_sum + candidates[i] > target:
                    return

                if i > begin and candidates[i] == candidates[i - 1]:
                    continue

                cur_sum += candidates[i]
                A.append(candidates[i])
                back_track(A, cur_sum, i + 1)
                cur_sum -= candidates[i]
                A.pop()

        candidates.sort()
        back_track([], 0, 0)
        return res
```

å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬åœ¨ä»£ç ä¸­å¢åŠ äº†ä¸€æ®µå‰ªæï¼š

```python
if i > begin and candidates[i] == candidates[i - 1]:
    continue
```

å¹¶ä¸”åœ¨å›æº¯çš„æ—¶å€™æŠŠ begin è®¾ç½®ä¸ºäº† `i+1`ï¼Œä¸ªäººçš„ç†è§£æ˜¯ï¼Œè¿™ä¸€æ­¥æ“ä½œæ’é™¤äº†å½“å‰å±‚çš„èŠ‚ç‚¹ï¼Œä»ä¸‹ä¸€å±‚å¼€å§‹æ‰¾ï¼Œè¾¾åˆ°äº†æˆ‘ä»¬å‰ªæçš„ç›®çš„ã€‚ï¼ˆå»é‡â€œåŒä¸€æ ‘å±‚ä¸Šä½¿ç”¨è¿‡çš„â€å…ƒç´ ï¼‰

```python
back_track(A, cur_sum, i + 1)
```

å¯¹è¿™ä¸ª `begin`çš„ç†è§£æ˜¯ï¼šå…¶ä½œç”¨ç›¸å½“äºæ ‡è®°äº† used å…ƒç´ ï¼ˆä½¿ç”¨ used æ•°ç»„æ ‡è®°æ•ˆæœç›¸åŒï¼‰ï¼Œæˆ‘ä»¬åœ¨ sort() çš„æƒ…å†µä¸‹ç”¨ begin æ˜¯å¯ä»¥çš„ã€‚

**ï¼ˆéœ€è¦åŠ æ·±ç†è§£ï¼Œä¸ä¸€å®šæ­£ç¡®ã€‚ï¼‰**

### LC46 å…¨æ’åˆ—

åœ¨è§£å†³äº†ä¸Šé¢çš„é‚£äº›é—®é¢˜ä»¥åï¼Œå…¨æ’åˆ—é—®é¢˜å°±å˜å¾—ç®€å•äº†ï¼Œå…¨æ’åˆ—é—®é¢˜ä¸¾ä¾‹å¦‚ä¸‹ï¼š

>ç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ `nums` ï¼Œè¿”å›å…¶ **æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ—** ã€‚ä½ å¯ä»¥ **æŒ‰ä»»æ„é¡ºåº** è¿”å›ç­”æ¡ˆã€‚
>
>è¾“å…¥ï¼šnums = [1,2,3]
>
>è¾“å‡ºï¼š[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

è¯¥é¢˜ç›®ä½¿ç”¨å›æº¯å¯ä»¥å¾ˆæ–¹ä¾¿çš„æ±‚è§£ï¼š

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []

        def back_track(path):
            if len(path) == len(nums):
                res.append(path[:])
                return
            
            for i in range(len(nums)):
                if nums[i] in path:
                    continue

                path.append(nums[i])
                back_track(path)
                path.pop()

        back_track([])
        return res
```

å…¨æ’åˆ—æ˜¯ç»å…¸çš„å›æº¯é—®é¢˜ï¼Œå¥—ç”¨å›æº¯æ¨¡æ¿å¯ä»¥å¾ˆè½»æ¾æ±‚è§£ã€‚

### LC47 å…¨æ’åˆ—II

>ç»™å®šä¸€ä¸ªå¯åŒ…å«é‡å¤æ•°å­—çš„åºåˆ— `nums` ï¼Œ**æŒ‰ä»»æ„é¡ºåº** è¿”å›æ‰€æœ‰ä¸é‡å¤çš„å…¨æ’åˆ—ã€‚
>
>è¾“å…¥ï¼šnums = [1,1,2]
>
>è¾“å‡ºï¼š
>[[1,1,2],
> [1,2,1],
> [2,1,1]]

è§£æ³•å¦‚ä¸‹ï¼š

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []

        def back_track(path: List, visited: List):
            if len(path) == len(nums):
                res.append(path[:])
                return

            for i in range(len(nums)):
                if visited[i] == 1:
                    continue
				
                # visited[i - 1] == 1 åœ¨è¯¥é¢˜ç›®ä¸­åŒç†ï¼Œä½†æ˜¯æ€§èƒ½è¾ƒå·®
                if i > 0 and nums[i] == nums[i - 1] and visited[i - 1] == 0:
                    continue

                visited[i] = 1
                path.append(nums[i])
                back_track(path, visited)
                visited[i] = 0
                path.pop()

        nums.sort()

        visited = [0 for _ in nums]
        back_track([], visited)
        return res
```



è¿™é“é¢˜ç›®ä¸åŒäº*å…¨æ’åˆ—*çš„ç‚¹åœ¨äºï¼š

- é›†åˆä¸­æœ‰é‡å¤çš„å…ƒç´ ï¼Œä½†æ˜¯æœ€åçš„ç»“æœä¸­ä¸èƒ½æœ‰é‡å¤çš„ç»„åˆã€‚æˆ‘ä»¬éœ€è¦å¯¹ç»“æœè¿›è¡Œå»é‡ï¼ˆç›´è§‚çš„æ€è·¯æ˜¯ç”¨setï¼Œä½†æ˜¯å®¹æ˜“è¶…æ—¶ï¼‰
- nums[i] å’Œ nums[i - 1] å¯ä»¥ç†è§£ä¸ºåŒä¸€å±‚çš„å½“å‰é€‰é¡¹å’ŒåŒä¸€å±‚çš„å‰ä¸€ä¸ªé€‰é¡¹
- è¯¥é¢˜ç›®ä¸­æœ‰ä¸¤ä¸ªå˜é‡å»é‡ï¼Œå¦‚æœä»…æœ‰`num[i] == num[i-1]`æ¡ä»¶å­˜åœ¨ï¼Œé€’å½’æ—¶ä¼šæŠŠç›¸åŒå…ƒç´ å»é™¤ï¼Œæ˜¾ç„¶ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ï¼Œæ‰€ä»¥åŠ ä¸Šäº† `vistied`ï¼Œé˜²æ­¢æ¼æ‰å…ƒç´ 
- å¦‚æœ `visited[i - 1] == 1`ï¼Œè¯´æ˜åœ¨åŒä¸€å±‚ï¼Œå¹¶ä¸” `num[i] == num[i-1]`ï¼Œæ‰€æœ‰å¯èƒ½çš„ç»„åˆéƒ½æ—©å·²è¢«è¿™ä¸€å±‚ç¬¬ä¸€æ¬¡å‡ºç°çš„é‚£ä¸ªç›¸åŒæ•°ç©·å°½äº†ï¼Œä¸éœ€è¦å†ç”»è›‡æ·»è¶³ã€‚

:::warning todo

éœ€è¦æ‹¿ iPad ç”»å›¾åˆ†æä¸€ä¸‹ visited[i - 1] == 1 å’Œ visited[i - 1] == 0 çš„å‰ªæå·®å¼‚ï¼Œå¯ä»¥å‚è€ƒ [é¢˜è§£](https://leetcode-cn.com/problems/permutations-ii/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-ki1h/)

:::

### LC77 ç»„åˆ

>ç»™å®šä¸¤ä¸ªæ•´æ•° `n` å’Œ `k`ï¼Œè¿”å›èŒƒå›´ `[1, n]` ä¸­æ‰€æœ‰å¯èƒ½çš„ `k` ä¸ªæ•°çš„ç»„åˆã€‚
>
>ä½ å¯ä»¥æŒ‰ **ä»»ä½•é¡ºåº** è¿”å›ç­”æ¡ˆã€‚
>
>è¾“å…¥ï¼šn = 4, k = 2
>è¾“å‡ºï¼š
>[
>  	[2,4],
>  	[3,4],
>  	[2,3],
>  	[1,2],
>  	[1,3],
>  	[1,4],
>]

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res = []

        nums = [i + 1 for i in range(n)]

        def back_track(path: List, begin):
            if len(path) == k:
                res.append(path[:])
                return

            for i in range(begin, len(nums)):
                if i > begin and nums[i] == nums[i - 1]:
                    continue

                path.append(nums[i])
                back_track(path, i + 1)
                path.pop()

        back_track([], 0)
        return res
```

## ä¾‹é¢˜è§£æ - DFS ç±»

### LC37 è§£æ•°ç‹¬

[37. è§£æ•°ç‹¬](https://leetcode-cn.com/problems/sudoku-solver/)

æˆ‘ä»¬å…ˆç»™å‡ºè¿™ä¸ªé¢˜ç›®çš„è§£æ³•ï¼Œç„¶åå¯¹è¿™ä¸ªè§£æ³•è¿›è¡Œæ·±å…¥çš„åˆ†æï¼š

```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        æ³¨æ„æ•°ç»„boardæ˜¯9*9å¤§å°çš„
        """

        # line ç”¨æ¥ä¿å­˜è¿™ä¸€è¡Œæ˜¯å¦æŸä¸ªæ•°å­—å·²ç»å‡ºç°è¿‡ line[2][4-1]è¡¨ç¤ºç¬¬2è¡Œæ•°å­—4å·²ç»å‡ºç°è¿‡
        line = [[False] * 9 for _ in range(9)]
        # colume ç”¨æ¥è¡¨ç¤ºè¿™ä¸€åˆ—æŸä¸ªæ•°å­—æ˜¯å¦å·²ç»å‡ºç°è¿‡
        colume = [[False] * 9 for _ in range(9)]
        # block è¡¨ç¤ºè¿™ä¸ªä¹å®«æ ¼é‡Œé¢æŸä¸ªæ•°å­—å·²ç»å‡ºç°è¿‡ block[i][j][num]
        # è¿™ä¸ªé‡Œé¢æœ‰ä¸€ä¸ªå¯¹åº”å…³ç³»ï¼Œåæ ‡ä¸º i,j çš„æ•°å­—å…¶åœ¨ä¹å®«æ ¼é‡Œé¢çš„åæ ‡ä¸º [i/3], [j/3] å‘ä¸‹å–æ•´
        block = [[[False] * 9 for _ in range(3)] for i in range(3)]
        spaces = []
        valid = False

        def dfs(pos: int):
            # æ€è€ƒï¼šè¿™ä¸ªvalidç”¨æ¥åšä»€ä¹ˆï¼Ÿ
            nonlocal valid
            if pos == len(spaces):
                valid = True
                return

            i, j = spaces[pos]
            for num in range(9):
                if line[i][num] == colume[j][num] == block[i // 3][j // 3][num] is False:
                    line[i][num] = colume[j][num] = block[i // 3][j // 3][num] = True
                    board[i][j] = str(num + 1)
                    dfs(pos + 1)
                    line[i][num] = colume[j][num] = block[i // 3][j // 3][num] = False
                if valid:
                    return

        # åˆå§‹åŒ–ä¸€ä¸‹è¿™äº›å˜é‡
        for i in range(9):
            for j in range(9):
                if board[i][j] == '.':
                    spaces.append((i, j))
                else:
                    # int(board[i][j]) - 1 æ˜¯å› ä¸ºæˆ‘ä»¬å®šä¹‰äº† [i][x-1]è¿™æ ·
                    digit = int(board[i][j]) - 1
                    line[i][digit] = colume[j][digit] = block[i // 3][j // 3][digit] = True
        dfs(0)
        # é¢˜ç›®è¦æ±‚åŸåœ°æ”¹å˜ boardï¼Œæ‰€ä»¥æˆ‘ä»¬å°±æ²¡æœ‰ return
```

è§£æ•°ç‹¬æ¸¸æˆæ˜¯å¦‚ä½•åº”ç”¨å›æº¯æ€æƒ³çš„ï¼Ÿæˆ‘ä»¬é€šè¿‡é¢˜ç›®ä¸­çš„ä¸€äº›ç»†èŠ‚æ¥ç®¡ä¸­çª¥è±¹ä¸€ç•ªã€‚

1. å…³äº `line`, `colume`, `block`çš„åˆå§‹åŒ–

   æˆ‘ä»¬å°†è¿™ä¸‰ä¸ªå˜é‡åˆ†åˆ«åˆå§‹åŒ–ï¼š

   - `line `ç”¨æ¥ä¿å­˜è¿™ä¸€è¡Œæ˜¯å¦æŸä¸ªæ•°å­—å·²ç»å‡ºç°è¿‡; `line[2][4-1]`è¡¨ç¤ºç¬¬ 2 è¡Œæ•°å­— 4 å·²ç»å‡ºç°è¿‡ï¼Œè¡¨ç°å½¢å¼ä¸º `line[2][3]`ï¼Œæˆ‘ä»¬çš„ä¸‹æ ‡æ˜¯ä» 0 å¼€å§‹çš„ï¼›`colume` ä¹Ÿæ˜¯åŒç†çš„ï¼Œä¸å¤šèµ˜è¿°ã€‚
   - å¯¹äº `line` å’Œ `colume` çš„åˆå§‹åŒ–ï¼Œæˆ‘ä»¬çŸ¥é“è¦åˆå§‹åŒ–äºŒç»´æ•°ç»„ï¼Œå¹¶ä¸”æ•°ç»„çš„é•¿å’Œå®½éƒ½ä¸º 9, è¿™æ ·æ¯”è¾ƒç®€å•ã€‚
   - æˆ‘ä»¬å°†æ‰€æœ‰åˆå§‹åŒ–åˆå§‹å€¼éƒ½è®¾ç½®ä¸º `False`, è¿™æ˜¯å› ä¸ºæˆ‘ä»¬ç­‰ä¼šå„¿è¦éå†æ•´ä¸ª board, å°†å·²ç»å¡«å†™è¿‡çš„æ•°å­—è®¾ç½®ä¸º `True`, ç¬¦åˆé€»è¾‘ã€‚

2. ä¸€äº›è§„å¾‹

   åœ¨ä¹å®«æ ¼ä¸­ï¼Œå¦‚æœç»™å®šäº†æŸä¸ªåæ ‡ `(i, j)`, é‚£ä¹ˆæˆ‘ä»¬å°±èƒ½è®¡ç®—å‡ºæ¥è¿™ä¸ªåæ ‡åœ¨ä¹å®«æ ¼ä¸­çš„ä½ç½®ï¼›å…·ä½“çš„è§„å¾‹æ˜¯ï¼š**ç¬¬ i è¡Œç¬¬ j åˆ—çš„æ ¼å­ä½äºç¬¬ ï¼ˆi//3, j//3) ä¸ªä¹å®«æ ¼ä¸­ï¼ˆå‘ä¸‹å–æ•´ï¼‰**ã€‚å…¶åŸç†åœ¨äºï¼šä¹å®«æ ¼çš„èŒƒå›´ä¸º $0 <= x <= 2$, $0 <= y <= 2$ã€‚

   å¦‚æœæˆ‘ä»¬æŠŠè¿™ä¸ªè§„å¾‹æ‰©å±•ä¸€ä¸‹ï¼Œå¯¹äºä¸€ä¸ª 16 å®«æ ¼ï¼Œè¿™ä¸ªåæ ‡ä¼šå˜æˆä»€ä¹ˆæ ·å­å‘¢ï¼Ÿé€šè¿‡ç”»å›¾æˆ‘ä»¬å‘ç°å°±æ˜¯æ•´é™¤ 4 ç„¶åå‘ä¸‹å–æ•´ï¼Œå¯ä»¥è®°ä½è¿™ä¸ªè§„å¾‹ã€‚

   :::tip ğŸ‰ğŸ‰ğŸ‰ Python çš„å‘ä¸‹å–æ•´å’Œå‘ä¸Šå–æ•´

   - å‘ä¸‹å–æ•´ç›´æ¥æ•´é™¤ï¼›ä¹Ÿå¯ä»¥ä½¿ç”¨ `math.floor()`;
   - å‘ä¸Šå–æ•´ï¼š`math.ceil()`ã€‚

   :::

3. æˆ‘ä»¬ä½¿ç”¨äº† dfs, ä¸å¯é¿å…çš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼šé€’å½’çš„ç»ˆæ­¢æ¡ä»¶æ˜¯ä»€ä¹ˆï¼Ÿ

   è¿™ä¸ªé¢˜ç›®ä½¿ç”¨çš„æ–¹æ³•ååˆ†å·§å¦™ï¼Œé¦–å…ˆå°† board éå†ä¸€éï¼Œå°†å…¶ä¸­æ‰€æœ‰çš„éæ•°å­—çš„åæ ‡æ‹¿å‡ºæ¥ï¼Œç„¶åéå†è¿™äº›éæ•°å­—åæ ‡çš„é›†åˆã€‚dfs çš„éå†æ˜¯æ ‡è®°éå†åˆ°ç¬¬å‡ ä¸ªï¼Œå½“æˆ‘ä»¬çš„ `pos` å’Œæ‰€æœ‰åæ ‡é›†åˆ `spaces`çš„é•¿åº¦ç›¸ç­‰æ—¶ï¼Œéå†å°±ç»“æŸäº†ã€‚

4. æˆ‘ä»¬ä¸ºä»€ä¹ˆè¦ä½¿ç”¨ä¸€ä¸ª `valid`å˜é‡ï¼Ÿ

   é¦–å…ˆè¦æ€è€ƒï¼Œè¦æ˜¯ä¸ä½¿ç”¨è¿™ä¸ªå˜é‡çš„è¯ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿæˆ‘ä»¬å°è¯•å°† `valid` ç›¸å…³çš„é€»è¾‘åˆ é™¤ä»¥åï¼Œå‘ç°ç­”æ¡ˆæ˜¯é”™è¯¯çš„ã€‚

   ç›®å‰çš„è§£é‡Šæ˜¯ï¼Œå¦‚æœæ‰¾åˆ°äº†ç»“æœä¸åœæ­¢ DFS çš„å¾ªç¯è°ƒç”¨çš„è¯ï¼Œä¼šè¦†ç›–æ‰æ­£ç¡®çš„ç­”æ¡ˆã€‚

   â“â“â“ åç»­éœ€è¦æ€è€ƒï¼šæ˜¯å¦å’Œ `board`æ˜¯å¼•ç”¨ä¼ å€¼æœ‰å…³ï¼Ÿ

5. è¿›é˜¶ï¼š

   è¿™é“é¢˜ç›®è¿˜å­˜åœ¨ä¸¤ç§è¿›é˜¶çš„æ–¹å¼ï¼ŒåŒ…æ‹¬ï¼šä½è¿ç®—çš„ä¼˜åŒ–å’Œæšä¸¾ï¼Œå…·ä½“å¯ä»¥å‚è€ƒå®˜æ–¹é¢˜è§£ã€‚

### LC79 å•è¯æœç´¢

[79. å•è¯æœç´¢](https://leetcode-cn.com/problems/word-search/)

> ç»™å®šä¸€ä¸ª `m x n` äºŒç»´å­—ç¬¦ç½‘æ ¼ `board` å’Œä¸€ä¸ªå­—ç¬¦ä¸²å•è¯ `word` ã€‚å¦‚æœ `word` å­˜åœ¨äºç½‘æ ¼ä¸­ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚

è¿™é“é¢˜ç›®éå¸¸æœ‰æ„æ€ï¼Œæ€è€ƒè¿™ä¸ªé¢˜ç›®ï¼Œæˆ‘ä»¬é€šå¸¸ä¼šæƒ³åˆ° BFS + å‰ªæï¼Œè¿™é“é¢˜ç›®è¦å’Œå›æº¯å…³è”ä¸Šï¼Œæˆ‘ä»¬éœ€è¦æ€è€ƒä¸€äº›é—®é¢˜ï¼Œä»¥åè§£å†³èµ·æ¥è¿™ç§é¢˜ç›®ä¹Ÿæ›´åŠ ç®€å•ä»å®¹ï¼š

1. å¦‚ä½•å¼€å§‹ï¼Ÿæˆ‘ä»¬å¯ä»¥å†™ä¸€äº›æˆ‘ä»¬æ¯”è¾ƒæ“…é•¿çš„ï¼Œæ¯”å¦‚è¯´ `board`çš„æŸä¸ªåæ ‡ï¼Œæ˜¯ä¸æ˜¯åˆæ³•çš„ï¼Œè¿™ä¸ªåæ ‡çš„ä¸Šä¸‹å·¦å³åæ ‡æˆ‘ä»¬å¯ä¸å¯ä»¥æ‹¿åˆ°ï¼Ÿ

   æˆ‘ä»¬å®šä¹‰å¯»è·¯é—®é¢˜ä¸­åŸºæœ¬çš„æ–¹å‘æ•°ç»„ `directs = [(0, -1), (0, 1), (-1, 0), (1, 0)]`

2. å¦‚æœç¡®å®šä½¿ç”¨å›æº¯ï¼ˆæˆ–è€…DFSï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯èƒ½ä¼šéœ€è¦ä¸€ä¸ª `visited`æ•°ç»„è¿›è¡Œæ ‡è®°ï¼Œè¿™æ˜¯ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œå…¶åˆå§‹åŒ–æ–¹å¼ä¸ºï¼š`visited = [[False] * len(board[0]) for _ in len(board)] `,æˆ–è€…åœ¨ python ä¸­æˆ‘ä»¬ä½¿ç”¨æ›´åŠ ç®€å•æš´åŠ›çš„ set() æ¥è§£å†³ã€‚

å®ç°çš„ä»£ç å¦‚ä¸‹ï¼š

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        directs = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def back_track(i, j, k):
            if word[k] != board[i][j]:
                return False
            if k == len(word) - 1:
                return True
            visited.add((i, j))
            for di, dj in directs:
                newi, newj = i + di, j + dj
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                    if (newi, newj) not in visited:
                        if back_track(newi, newj, k + 1):
                            return True
            visited.remove((i, j))
            return False

        visited = set()
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == word[0]:
                    if back_track(i, j, 0):
                        return True
        return False
```

æˆ‘ä»¬å›æº¯ï¼ˆæˆ–è€… DFSï¼‰è¿›å…¥çš„å‡½æ•°æœ‰ä¸‰ä¸ªå‚æ•°ï¼Œ`(i, j, k)`, å…¶ä¸­ `k` è¡¨ç¤º word ä¸­çš„ç¬¬ k ä¸ªå­—ç¬¦ã€‚

- æˆ‘ä»¬å¾ªç¯éå† `board`ï¼Œç›´åˆ°æ‰¾åˆ°å’Œ `word`ç¬¬ä¸€ä¸ªå­—ç¬¦ç›¸ç­‰çš„ä½ç½® `(i, j)`, ç„¶åä» `(i, j)`å¼€å§‹å›æº¯ï¼›å¦‚æœæ²¡æœ‰æ‰¾åˆ°è¿™ä¸ªç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œåˆ™ç›´æ¥è¿”å› `False`ã€‚ 
- æˆ‘ä»¬åœ¨å†™é€’å½’çš„æ—¶å€™è¦æƒ³æ¸…æ¥šé€’å½’çš„è¿”å›æ¡ä»¶ï¼Œæ€è€ƒå‰ªææˆ–è€…é€€å‡ºçš„æ¡ä»¶ã€‚

é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªæ›´å®¹æ˜“ç†è§£çš„å†™æ³•ï¼š

```python
    def exist2(self, board: List[List[str]], word: str) -> bool:
        def search(i, j, k):
            # é€’å½’ç»ˆæ­¢æ¡ä»¶
            if k >= len(word):
                return True

            if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) \
                    or board[i][j] != word[k] or (i, j) in visited:
                return False
            visited.add((i, j))

            ret = search(i + 1, j, k + 1) or search(i, j + 1, k + 1) \
                  or search(i - 1, j, k + 1) or search(i, j - 1, k + 1)

            visited.remove((i, j))
            return ret

        visited = set()
        for i in range(len(board)):
            for j in range(len(board[0])):
                res = search(i, j, 0)
                if res:
                    return True
        return False
```

è¿™ä¸ªåšæ³•çš„ä¼˜ç‚¹åœ¨äºï¼Œæ–¹ä¾¿ç†è§£ã€‚æˆ‘ä»¬ä» (i, j, 0) å¼€å§‹æœç´¢ï¼Œè€Œåè®¾ç½®é€’å½’çš„ç»ˆæ­¢æ¡ä»¶å’Œé”™è¯¯æ¡ä»¶ã€‚

`visited.remove((i, j))`æ˜¯åœ¨æˆ‘ä»¬è¿›è¡Œäº†æœç´¢åè¿›è¡Œå›æº¯ã€‚

è¿™ä¸ªä»£ç ç®€å•æ˜“æ‡‚ï¼ŒçœŸä¸é”™ï¼
